<!DOCTYPE html>
<html>
    <head>
        <title>EBA - Key Functional Interactions</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            EBA - Key Functional Interactions
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    
                    <div id="main-content" class="wiki-content group">
                    <p>The component interactions to perform key functional activities of the Environment Build and Management subsystem of EBA are given here. It supports the following capabilities:</p><ul><li>Automated build and modification of cloud hosted resources (virtual applications, virtual machines and networks) using the ACloud Client API based upon configuration managed meta data (XML definition files) and operating system templates</li><li>Automated layering and modification of the following configuration managed meta data and deployment artifacts onto the virtual machines:<br /><ul><li>Operating system configuration</li><li>Operating system patching</li><li>Middleware installation</li><li>Middleware configuration</li><li>Middleware patching</li><li>Application code installation (onto Middleware)</li><li>Application code configuration</li></ul></li></ul><p class="Bodycopy">An overview of the Environment Build and Management sub-system of EBA is given in the <a href="EBA---Architecture-Overview_65471092.html">EBA Architecture Overview</a>.</p><h1 id="EBA-KeyFunctionalInteractions-CreateEnvironment">Create Environment</h1><p>At a high level, environments will be built in layers from the ground up using configuration managed meta data.  Each layer is completed before progressing on to the next to enable progress to be tracked within the Environment Action Orchestrator user interface.  The order in which layers are applied to a new environment containing two virtual machine containers is shown in the diagram below:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="attachments/65482098/65482414.png" data-image-src="attachments/65482098/65482414.png" data-unresolved-comment-count="0" data-linked-resource-id="65482414" data-linked-resource-version="3" data-linked-resource-type="attachment" data-linked-resource-default-alias="Environment Build Layers.png" data-base-url="https://<confluenceurl>" data-linked-resource-content-type="image/png" data-linked-resource-container-id="65482098" data-linked-resource-container-version="35"></span></p><p style="text-align: center;"><strong>Figure 2 - Environment Build Layers</strong></p><p>The environment build process outlined within the diagram above starts at the bottom and progresses upward (in the direction of the arrows) through a number of different layers to provision the required virtual machine resources within the cloud (steps 1 to 5), power them on in a specific order (step 6a and 7b), configure the operating system (steps 7a and 7b) and configure the software and services within those hosts (steps 8 to 13).</p><p>Due to the number of steps involved in creating a new environment this key functional interaction has been broken down into a number of parts:</p><ul><li>Environment Design - Designing an environment and having it saved in the Environment Build Repository.</li><li>Create Part A - Building the required virtual resources within the cloud, powering them on and enabling those new resources to communicate with the EBSA tooling, enabling the new virtual machines to be configured by the Environment Configuration Orchestration component (MCollective).</li><li>Create Part B - Building and configuring the software on each new virtual machine using the Environment Configuration Orchestration component (MCollective) in order to provide a fully functioning environment that can be handed over and then managed within a business as usual manner.</li></ul><p>This is shown in more detail within the following key interaction diagrams and associated narrative:</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="attachments/65482098/65493615.png" data-image-src="attachments/65482098/65493615.png" data-unresolved-comment-count="0" data-linked-resource-id="65493615" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="DesignEnvironment.png" data-base-url="https://<confluenceurl>" data-linked-resource-content-type="image/png" data-linked-resource-container-id="65482098" data-linked-resource-container-version="35"></span></p><p style="text-align: center;"><strong>Figure 3 - Design Environment</strong></p><ol><li style="text-align: left;">An EBSA administrator creates an environment definition (a network design) using the Environment Design component and, also using the same component, exports the design, commits and pushes to the central Environment Action Repository. An EBSA administrator also manually creates the associated build plan and configuration data as set of environment configuration files locally, commits the changes and pushes them to the central Environment Action Repository.  In this scenario, there would be:<ol><li>A single environment definition file containing the details of the new environment’s resources to build within the cloud. This file is created by using the Environment Design component.</li><li>A number of environment execution plans to perform different actions on the environment definition file i.e. create environment, power on certain machines, etc. and a single dynamic environment data file containing the data that will be stored within the Dynamic Environment Data Repository (Hiera database) that is used to configure environment specific meta data (e.g. packages / package versions) on the newly built virtual machines within the new environment.</li></ol></li></ol><p style="text-align: left;"><strong><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="attachments/65482098/65491301.png" data-image-src="attachments/65482098/65491301.png" data-unresolved-comment-count="0" data-linked-resource-id="65491301" data-linked-resource-version="4" data-linked-resource-type="attachment" data-linked-resource-default-alias="Create Environment pt A NEW.png" data-base-url="https://<confluenceurl>" data-linked-resource-content-type="image/png" data-linked-resource-container-id="65482098" data-linked-resource-container-version="35"></span><br /></strong></p><p style="text-align: center;"><strong>Figure 4 - Create Environment (Part A)</strong></p><p style="margin-left: 30.0px;">2. The EBSA administrator manually triggers the “Build Environment (with parameters)” job which gathers information from the EBSA Administrator and Environment Build Repository to determine the environment which is to be built and the administrators wishes regards invoking the build operation as follows:</p><ol><li style="list-style-type: none;background-image: none;"><ol><li>Determine the set of available environment build plans (using the Environment Action Repository)  and, after the EBSA Administrator has selected an environment/action, the available versions of the chosen environment from the Environment Build Repository for the EBSA Administrator to chose the version of the chosen environment to apply the build action to.</li><li>Invoke the Environment Build to generate an Action Plan of actions to be performed to fulfill the build request for the EBSA Administrator to review.</li><li>Invoke the Environment Build to perform the build through the following steps.</li></ol></li></ol><p style="margin-left: 30.0px;">3. The Environment Build will call the ACloud Client CLI passing in the Environment Definition file and the Environment Execution Plan and use the details specified within the definition file to create the resources required in the cloud for the new environment.  Different calls from Environment Build will orchestrate the following calls to the Skyscape or AWS API:</p><ol><li style="list-style-type: none;background-image: none;"><ol><li>Create the virtual machine containers (from details within the environment definition file)</li><li>Assign the organisation networks into the virtual machine containers (from details within the environment definition file)</li><li>Create the virtual application networks within the virtual machine containers (from details within the environment definition file)</li><li>Instantiate the required virtual machines within the virtual machine containers (from details within the environment definition file).  These are instantiated from base operating system images held within a private catalogue in the Cloud Hosting Provider component.  Once instantiated, each virtual machine is updated (recomposed) to set its hostname, CPU, memory, storage, network interface cards and guest OS customisation script location - to align to the details specified within the environment definition file</li></ol></li></ol><p style="margin-left: 30.0px;">4. Once the required resources are created and reconfigured within the cloud Environment Build will call the ACloud Client again with a power on execution plan for just the management firewalls within each newly created virtual machine container.  The management zone firewall is powered on first to provide management network connectivity to all virtual machines within each virtual machine container, before the other virtual machines are powered on.</p><p style="margin-left: 30.0px;">5. <span class="confluence-anchor-link" id="EBA-KeyFunctionalInteractions-customisationscript"></span>The ACloud Client is again invoked from Environment Build and will receive the Environment Definition file and the Environment Execution Plan, this step will be called twice as part of two passes, initially to power on the management zone firewalls across all virtual machine containers, and then to power on the remaining virtual machines across all virtual machine containers.</p><ol><li style="list-style-type: none;background-image: none;"><ol><li>The power on command will be issued to the respective virtual machines via the API.  When each virtual machine is powered on VMware (Skyscape) or AWS (when targeting Amazon) will trigger a Guest OS Customisation script (which runs on power on).  The location of this file is set when the VM is reconfigured, and will be retrieved from the Environment Action Repository and executed.  This script will perform the following actions on each virtual machine:<ol><li>Configure the gateway network addresses (as they cannot be set in the API) for firewall virtual machines</li><li>Configure the hosts file</li><li>Configures the Environment Configuration Controller (Puppet) agent to enable it to communicate with the Environment Configuration Controller (Puppet Master)</li><li>Perform a one time Puppet run in order to obtain the configuration from the Puppet Master of the Environment Configuration Orchestration (MCollective) to bootstrap it</li></ol></li></ol></li></ol><p style="margin-left: 30.0px;">6. The Environment Build will wait for the Guest OS Customisation scripts to complete, which will include waiting for the Environment Configuration Orchestration process to bootstrap.</p><p style="margin-left: 30.0px;">7. As part of two passes (once for the management zone firewalls, and then the remaining virtual machines) the base operating system configuration will be applied to each host.  Once the Environment Configuration Orchestration bootstrap process is complete, each virtual application will be in a position to communicate with the Environment Configuration Controller to request the Environment Configuration Orchestration component to apply specific controlled pieces of environment configuration (base operating system and network configuration) to that machine.</p><ol><li style="list-style-type: none;background-image: none;"><ol><li>The next child job is triggered to SSH onto the Environment Configuration Controller (Puppet Enterprise) host and trigger an Environment Configuration Orchestration (MCollective) request to be sent to the target virtual machine (the Management Zone Firewall) telling it to check and update its base operating system configuration.  N.B. The base operating system configuration (including network configuration) is applied to the Management Zone Firewall first to ensure that it can route to all other virtual machines within the respective virtual application, to enable them to be subsequently configured.</li><li>The Environment Build will receive control back from the child job before the base operating system configuration is applied (as the orchestration call is asynchronous).  Therefore, the next child job is introduced to poll (wait) until the base operating system configuration is complete before returning control back to the parent job.</li></ol></li></ol><p style="margin-left: 30.0px;">8. An agent on the target virtual machine receives the orchestrated request, and triggers the agent to gather a current set of facts about the host which it sends to the Environment Configuration Controller (Puppet Enterprise).  The controller determines which base operating system configuration changes should be on that virtual machine by identifying the correct puppet modules and dynamic data that should be applied to that host (by checking the details of the host from the facts).  In this scenario, none of the base operating system configuration would be present on the management firewall, and that difference would cause the Environment Configuration Controller to compile a set of instructions to be sent back to the agent on the target virtual machine to action the changes that would need to be made to the target operating system to align it to its intended configuration.</p><p style="margin-left: 30.0px;">9. The agent on the target virtual machine then actions the operating system configuration changes.  Once complete, the agent would report on its success back to the Environment Configuration Controller.  The waiting child job would also then complete, allowing the parent job to move onto the next child job in line.</p><p> </p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="attachments/65482098/65491845.png" data-image-src="attachments/65482098/65491845.png" data-unresolved-comment-count="0" data-linked-resource-id="65491845" data-linked-resource-version="2" data-linked-resource-type="attachment" data-linked-resource-default-alias="Create Environment pt B NEW.png" data-base-url="https://<confluenceurl>" data-linked-resource-content-type="image/png" data-linked-resource-container-id="65482098" data-linked-resource-container-version="35"></span></p><p style="text-align: center;"><strong>Figure 5 - Create Environment (Part B)</strong></p><p>10. Once each host has had its base operating system configuration applied, the following items are configured:</p><ol><li>External DNS</li><li>Internal DNS</li><li>External Routing</li><li>Monitoring</li></ol><p style="margin-left: 30.0px;">N.B. The pattern to apply this configuration is the same as step 7 (and is not described here again)</p><p>11. At this stage, all virtual machines across all virtual machine contaners within the new environment will have had their base operating system configuration, network and monitoring configuration applied.  A child job for each additional layer is then triggered in turn as per <strong><em>Figure 2 - Environment Build Layers</em></strong>.  As all of these layers will be implemented by installing different packages, each child job essentially calls the same job passing in different package / version information relative to the packages to be installed at that layer (see the Deploy Package key functional interaction for more details).</p><ol><li>Operating System Patching - will install a named / versioned list of patch packages onto each virtual machine from the Package Repositories component, based upon predefined dynamic environment data stating what patches are required for each operating system / version (e.g. RHEL 6.5).</li><li>Middleware Install - will install a named / versioned set of middleware packages onto each relevant virtual machine from the Package Repositories component, based upon predefined dynamic environment data stating what middleware packages are required for each host type (e.g. BPM server).  N.B. dependencies between the middleware install package and middleware patch packages may also bring in patches during this step.</li><li>Middleware Patching - will install a named / versioned list of patch packages onto each relevant virtual machine from the Package Repositories component, based upon predefined dynamic environment data stating what patches are required for each piece of middleware based upon the host type.</li><li>Middleware Base Configuration - will install a named / versioned list of middleware configuration packages onto each relevant virtual machine from the Package Repositories component, based upon predefined dynamic environment data stating what configuration packages are required for middleware / version within the estate.  N.B. Rather than apply all middleware base configuration to all virtual machines at the same time, an predefined order will be applied to control dependencies between middleware products e.g. a database has to be configured before an application server container can be configured to use it.</li><li>Application Code Install + Application Code / Middleware Configuration - will install a named / versioned list of application code packages into a Middleware container on each relevant virtual machine from the Package Repositories component, based upon predefined dynamic environment data stating what application code / versions are required for each middleware / version within the estate.</li></ol><h1 id="EBA-KeyFunctionalInteractions-DeployPackage">Deploy Package</h1><p><span style="color: rgb(0,0,0);">The following package description reflects the pre-self service design.</span></p><p><span style="color: rgb(0,0,0);">As part of the ongoing maintenance of environments, the following different types of packages will need to be deployed into an environment:</span></p><ol><li><span style="color: rgb(0,0,0);">Operating system and middleware patches</span></li><li><span style="color: rgb(0,0,0);">Middleware installations / upgrades</span></li><li><span style="color: rgb(0,0,0);">Application code installations / upgrades</span></li></ol><p><span style="color: rgb(0,0,0);">In order to provide a consistent and repeatable method of installing these packages, they will be packaged into a standard format and all be deployed using the same process.</span></p><p><span style="color: rgb(0,0,0);">The key functional interaction diagram for deploying packages, along with associated narrative is shown below:</span></p><p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="attachments/65482098/65482536.png" data-image-src="attachments/65482098/65482536.png" data-unresolved-comment-count="0" data-linked-resource-id="65482536" data-linked-resource-version="2" data-linked-resource-type="attachment" data-linked-resource-default-alias="Deploy Package.png" data-base-url="https://<confluenceurl>" data-linked-resource-content-type="image/png" data-linked-resource-container-id="65482098" data-linked-resource-container-version="35"></span></p><p align="center" style="text-align: center;"><strong>Figure 5 - Deploy package</strong></p><ol><li>An EBSA administrator manually triggers the “Deploy Package” job which orchestrates calls to a number of child jobs in order to deploy the required package, as part of triggering the job, the target virtual machines (environment and server role that determine where the package is to be deployed), the package name and the package version would be specified as job parameters.</li><li>The first child job that is called will be Update_Package_Data which will locate the relevant entry in the Hiera database and make changes to it to reflect the new version of the package to be deployed.  The changes are then committed and pushed to the Dynamic Environment Data Repository (Hiera database). </li><li>At this point the configured version of a package on the target machine has been altered, and within a short space of time the Environment Configuration Controller would automatically apply that change.  However, in this scenario it is assumed that an EBSA administrator intended for the package to be updated immediately.  As such, the second child job, ‘Run Puppet Agent’, SSHes onto the Environment Configuration Controller (Puppet Enterprise) server and triggers an Environment Configuration Orchestration (MCollective) request to be sent to the target virtual machine telling it to check and update its package deployment configuration.</li><li>The Environment Action Orchestrator will receive control back from the first child job before the package is deployed (as the orchestration call is asynchronous).  Therefore, a second child job is introduced to poll (waiting) until the package deployment is complete before returning control back to the parent job.</li><li>An agent on the target virtual machine receives the orchestrated request, and triggers the agent to gather a current set of facts about the host which it sends to the Environment Configuration Controller (Puppet Enterprise).  The controller determines which packages should be on that virtual machine by checking the details of the host (from the facts) against the Dynamic Data Repository.  In this scenario, the change to the dynamic data would mean that there was a difference that would be returned back to the Environment Configuration Controller which would compile a set of instructions to be sent back to the agent on the target virtual machine to action.</li><li>As part of actioning the difference in package versions, the agent on the target virtual machine would pull the new package from the respective Artifact Repository and install it.  The install and uninstall instructions would be contained within the package and run as part of the installation process.  Once the agent had completed the package install process, it would report on its success back to the Environment Configuration Controller.  The second child job (that was waiting) would also then complete, which in turn would complete the parent “Deploy Package” job.</li></ol>
                    </div>

                                        
                    
                 
                </div>             </div> 
            
        </div>     </body>
</html>
